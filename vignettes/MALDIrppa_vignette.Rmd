---
title: "Example robust pre-processing pipeline with MALDIrppa"
author: "[Javier Palarea-Albaladejo](http://www.bioss.ac.uk/people/javier.html), Biomathematics & Statistics Scotland, Edinburgh, UK"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: FaultyMSbiblio.bib
vignette: >
  %\VignetteIndexEntry{Put the title of your vignette here}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

<style>
pre {
  overflow-x: auto;
}
pre code {
  word-wrap: normal;
  white-space: pre;
}
</style>

```{r global_options, include=FALSE}
options(width = 999)
knitr::opts_chunk$set(fig.align='center', fig.width=6.5, fig.height=5.5, message=FALSE)
```

## Introduction

MALDIrppa contributes a number of procedures for robust pre-processing and analysis of MALDI mass spectrometry (MS) data. It is thought to work in conjuction with the `MALDIquant` package [@Gibb2012], using object classes and methods from this latter while providing additional functionality. These notes serve as basic guidelines for users to run a complete robust MALDI-TOF mass spectra pre-processing pipeline using their own data with small adaptations. Further specific details and examples about the functions can be obtained using the `?` help operator followed by the function name as normally in R.

The data set `spectra` used as example here is an anonymized collection of mass spectra trimmed to the [2500, 13000] _m/z_ interval and of low-resolution (30 times reduction from the original using the `redResolution` function) so as to make it manageable for sharing and illustration purposes. It consists of 4 technical replicates of 5 biological replicates from 20 bacterial isolates. The mass spectra were originally acquired over a [2000, 20000] Daltons mass range using a Bruker Daltonics Ultraflex II mass spectrometer. The data set `type` contains associated metadata.

The following sections will go through the stages to transform raw mass spectra into formats suitable for downstream data analysis and modelling for biological interpretation. These involve data transformation, smoothing, baseline correction, normalisation, peak detection and peak aligment and binning. The features of the signals depend on technological progress and characteristics of the species under study. There is not a standard methodology for MS data pre-processing, including the order of the stages, best working in all cases. This document provides a generic pipeline through `MALDIrppa` based on robust statistical methods which contributes to lessen the intrinsic reproducibility issues with MS data and facilitates obtaining reliable biological conclusions [@Mclean2016]. However, the finest pre-processing in a particular case might require further discussion of choices for parameter settings and methods.

## Getting started

The data are included in `MALDIrppa` in the own R's `RData` binary file format. They can be loaded into the workspace simply using the `data` function.

```{r loading, echo=TRUE, eval=TRUE, results='hide'}
library(MALDIrppa)
```

```{r loading2, echo=TRUE, eval=TRUE, results='hide'}
data(spectra) # list of MassSpectra class objects
data(type)    # metadata
```

Alternatively, raw data stored in text files can be easily imported into R and given the convenient `MassSpectrum` class format using the `importSpectra` function in `MALDIrppa`. The function `summarySpectra` computes a table including some basic summary statistics. A look at these along with some graphical representations of them are useful to get a first insight into the data set and identify possible issues. The next code shows numerical results for the first 10 signals.

```{r summary, echo=TRUE, eval=TRUE}
summarySpectra(spectra[1:10])
```

A number of parameters are required to be set for the different pre-processing stages and we do this in a preliminary section. The functions include _safe_ default values, but parameter settings throughout pre-processing stages interact in complex ways. We have customised some of the key parameters so as to obtain optimal combinations in terms of sensibility and false discovery rate analysis of extracted peak features using simulated mass spectra data.

```{r parameters, echo=TRUE, eval=TRUE}
# Pre-processing parameter settings
thScale <- 2.5 # Smoothing
ite <- 105 # Baseline correction
SigNoi <- 3.5 # Peak extraction
hws <- 20 # Peak extraction
tol <- 0.003 # Peak binning
```

## Initial screening

Pre-processing methods are not immune to low-quality mass spectra and inadvertently letting them through can severely distort the results. For example, we observed that they produced both clusters of spurious peaks in some cases and sparse peaks in others which interfere with the determination of common reference peaks for peak alignment and binning. Common low-quality mass spectra are characterised by extremely ripply and indented profiles of low intensities. Moreover, ion supression cases show one or a few abnormally high peaks whereas the other peptide features are pulled down. The package `MALDIrppa` helps to detect exotic signals by a semi-automatic screening process implemented in `screenSpectra` based on robust scale estimators [@Rousseeuw1993] of the derivative mass spectra and median intensities. These components are combined to build an atypically score ($A$) for each signal, which is then labelled as suspicious (`failure`) if its score falls beyond the estimated tolerance limits (see help for `screenSpectra` for options available). The argument `lambda` distributes the weight given to each one of the components of $A$ ($\lambda = 1/2$ by default).

[//]:$$A = \frac{S^{\lambda}}{(\texttt{med}+1)^{(1-\lambda)/2}},$$

[//]:where $S$ is the robust scale estimator, $\texttt{med}$ is the median intensity of the raw signal and $\lambda$

The `screenSpectra` function generates a table `est.table` with individual information for each mass spectrum. The following code illustrates its use with default settings and creates a new `scSpectra` class object called `sc.results`. The function can take a matrix of metadata (`type` in our case) as argument. This is convenient to easily filter problematic cases out in both the spectra and metadata sets for subsequent analysis as shown below. Ordinary R methods `summary` and `plot` can be applied on `scSpectra` class objects to obtain a summary table and graphs of the results.

```{r iniscreening, echo=TRUE, eval=TRUE, fig.align='center', fig.width=6.5, fig.height=5.5}
# Initial screening ----
sc.results <- screenSpectra(spectra, meta = type)
summary(sc.results)
plot(sc.results, labels = TRUE)
```

The method `plot` also allows to visualise the distribution of the atypically scores and to customise the point labels, among other features. When `label = TRUE` it shows the position number of the mass spectra in the data set. It is advisable to visually inspect marked mass spectra, particular borderline cases, and further investigate any pattern. For example, in the example data set we observe that mass spectra number 25 to 28 correspond with a series of technical replicates within the same biological replicates (see e.g. `type[20:30,]`). Focusing on some of the most extreme $A$ scores, the following figures shows mass spectra 28, 29 and 87, which correspond with extremely ripply and indented, ion suppression and flat mass spectra respectively.

```{r spectraplots, echo=TRUE, eval=TRUE, fig.align='center', fig.width=6.5, fig.height=5.5}
plot(spectra[[28]])
plot(spectra[[29]])
plot(spectra[[87]])
```

For the purpose of this tutorial we simply move on updating the original `spectra` and `type` objects with the filtered collection of mass spectra and associated metadata provided by `screenSpectra` through the `fspectra` and `meta` elements of the output.

```{r iniscreening3, echo=TRUE, eval=TRUE}
spectra <- sc.results$fspectra # Filtered list of mass spectra
type <- sc.results$fmeta # Filtered metadata
```

## Denoising, baseline correction and normalisation

Following Coombes..., signal denoising or smoothing is conducted by undecimated discrete wavelet transform (UDWT). Wavelets adapt well to changes in peak shape and the UDWT produces the same results if the start of the signal is shifted by a few time points (shift-invariance). This prevents from undesirable artifacts into the signal near either end of the spectrum due to large changes in wavelet coefficients as a consequence of small shifts in location. For baseline correction, the statistics-sensitive non-linear iterative peak-clipping (SNIP) algorithm as implemented in `MALDIquant` generates positive intensities and provides better results with high matrix effects (pronounced mode). For normalisation we also stick to theoptions provided by `MALDIquant`. 



## Peak detection

summarySpectra Y summaryPeaks UTILES PARA DETECTAR PROBLEMAS, NA, INF, ... BY plotting statistics for example The number of peak extracted is also a very good indicative of problems, either excess or scarcity may reveal problems.


```{r deno, echo=TRUE, eval=FALSE}
# Denoising, baseline correction, normalisation ----
spectra <- transformIntensity(spectra, method = "sqrt")
spectra <- wavSmoothing(spectra, thresh.scale = thScale)
spectra <- removeBaseline(spectra, method = "SNIP", iterations = ite)
spectra <- calibrateIntensity(spectra)
```

```{r material, echo=TRUE, eval=FALSE}
# Peak detection ----
peaks <- detectPeaks(spectra, SNR = SigNoi, halfWindowSize = hws)

# Peak alignment and binning ----
peaks <- alignPeaks(peaks, minFreq = 0.8, tolerance = tol)

# Save pre-processed data ----
save(peaks, file = "peaks.new.Rdata")
save(type, file = "type.new.Rdata")

#################################################################################

## Post-processing

rm(list=ls())
load("peaks.new.Rdata")
load("type.new.Rdata")

# Outlier detection at isolate level based on intensities ----
aty <- detectOutliers(peaks, by = type$Isolate)
peaks.clean <- peaks[aty[,2]==FALSE] # discard outlying peaks
type.clean <- type[aty[,2]==FALSE,] # and corresponding metadata

# Or, outlier detection at isolate level based on peak presence/absence patterns ----
aty <- detectOutliers(peaks, type$Isolate, binary = TRUE)
peaks.clean <- peaks[aty[,2] == FALSE]
type.clean <- type[aty[,2] == FALSE,]

# Filtering and merging replicates ----

# Discard peaks occurring in less than 25% reps within isolate (bio rep level)
peaks.clean.f <- filterPeaks(peaks.clean, minFreq = 0.25, labels = type.clean$Isolate)

# Merge reps by the median
peaks.clean.fm <- mergeMassPeaks(peaks.clean.f, labels = type.clean$Isolate, method = "median")

# Note that the isolate labels are used to name merged spectra on the list

# Merge metadata accordingly
type.clean.fm <- aggregate(type.clean, list(Isolate = type.clean$Isolate), FUN = length)[,1]

# Obtain final intensity matrix ----
int.clean.fm <- intensityMatrix(peaks.clean.fm)

# Storing resulting intensity matrix in different formats ----
writeMetadata(type.clean.fm,filename="type.clean.fm",format="csv")
writeIntensity(int.clean.fm,filename="int.clean.fm",format="csv",labels=type.clean.fm$Isolate)
writeIntensity(int.clean.fm,filename="int.clean.fm",format="NEXUS",labels=type.clean.fm$Isolate)
```

# References